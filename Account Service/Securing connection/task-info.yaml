type: edu
files:
- name: src/account/AccountServiceApplication.java
  visible: true
  text: |-
    package account;

    import org.springframework.boot.SpringApplication;
    import org.springframework.boot.autoconfigure.SpringBootApplication;

    @SpringBootApplication
    public class AccountServiceApplication {

        public static void main(String[] args) {
            SpringApplication.run(AccountServiceApplication.class, args);
        }

    }
  learner_created: false
- name: src/resources/application.properties
  visible: true
  text: |-
    server.port=28852
    management.endpoints.web.exposure.include=*
    management.endpoint.shutdown.enabled=true
    spring.jackson.serialization.INDENT_OUTPUT=true
  learner_created: false
- name: build.gradle
  visible: true
  text: |-
    plugins {
        id 'java'
        id 'org.springframework.boot' version '2.3.1.RELEASE'
        id 'io.spring.dependency-management' version '1.0.9.RELEASE'
    }

    repositories {
        mavenCentral()
    }

    sourceSets.main.resources.srcDirs = ["src/resources"]

    dependencies {
        implementation 'org.springframework.boot:spring-boot-starter'
        implementation 'org.springframework.boot:spring-boot-starter-actuator'
        implementation 'org.springframework.boot:spring-boot-starter-web'
        implementation 'com.h2database:h2'
        implementation group: 'org.hibernate', name: 'hibernate-validator', version: '6.1.0.Final'
    }
  learner_created: false
- name: test/AccountServiceTest.java
  visible: false
  text: |
    import account.AccountServiceApplication;
    import org.hyperskill.hstest.dynamic.DynamicTest;
    import org.hyperskill.hstest.dynamic.input.DynamicTesting;
    import org.hyperskill.hstest.exception.outcomes.WrongAnswer;
    import org.hyperskill.hstest.mocks.web.request.HttpRequest;
    import org.hyperskill.hstest.stage.SpringTest;
    import org.hyperskill.hstest.testcase.CheckResult;

    import javax.net.ssl.*;
    import java.security.cert.X509Certificate;

    public class AccountServiceTest extends SpringTest {
      public AccountServiceTest() {
        super(AccountServiceApplication.class, "../service_db.mv.db");
      }

      SSLSocket socket;
      java.security.cert.X509Certificate[] chain;

      // Warning!!! Only for testing reason, trust all certificates!
      TrustManager[] trustAllCerts = new TrustManager[] {
              new X509TrustManager() {
                public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                  return new java.security.cert.X509Certificate[0];
                }
                public void checkClientTrusted(
                        java.security.cert.X509Certificate[] certs, String authType) {
                }
                public void checkServerTrusted(
                        java.security.cert.X509Certificate[] certs, String authType) {
                }
              }
      };

      // Test SSL
      public CheckResult checkCertificateName(String nameCN) {
        try {
          SSLContext sc = SSLContext.getInstance("SSL");
          //ТАК нельзя!!! доверяем всем сертификатам, только для тестирования и разработки!!!
          sc.init(null, trustAllCerts, new java.security.SecureRandom());
          SSLSocketFactory factory = sc.getSocketFactory();
          HttpRequest request = get("");
          socket = (SSLSocket) factory.createSocket(request.getHost(), request.getPort());
          getCertificates();
          if (findCert(nameCN)) {
            return CheckResult.correct();
          } else {
            throw new WrongAnswer("Not found certificate with CN - " + nameCN);
          }
        } catch (Exception e) {
          e.printStackTrace();
          System.out.println("Connection not found");
          throw new WrongAnswer("Can't establish https connection!");
        }
      }

      // Get certificate chain
      public void getCertificates() {
        try {
          chain = (X509Certificate[]) socket.getSession().getPeerCertificates();
        } catch (SSLPeerUnverifiedException e) {
          e.printStackTrace();
          System.out.println(e.toString());
        }
      }


      // Searching certificate by Common Name
      public boolean findCert(String subject) {
        for (java.security.cert.X509Certificate c : chain) {
          String subjectName = c.getSubjectDN().getName();
          System.out.println(subjectName + " " + c.getSigAlgName());
          if (subjectName.contains("CN=" + subject)) {
            return true;
          }
        }
        return false;
      }

      @DynamicTest
      DynamicTesting[] dt = new DynamicTesting[]{

              // Check certificate name
              () -> checkCertificateName("accountant_service"),
      };
    }
  learner_created: false
- name: src/account/dto/user/RoleDTO.java
  visible: true
  text: |
    package account.dto.user;

    import lombok.Getter;
    import lombok.RequiredArgsConstructor;

    @Getter
    @RequiredArgsConstructor
    public class RoleDTO {
        private final String user;
        private final String role;
        private final String operation;
    }
  learner_created: true
- name: src/account/controller/SecurityController.java
  visible: true
  text: |
    package account.controller;

    import account.model.event.Event;
    import account.service.EventService;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.RequestMapping;
    import org.springframework.web.bind.annotation.RestController;
    import java.util.List;

    @RestController
    @RequestMapping("/api/security")
    public class SecurityController {

        private final EventService eventService;

        @Autowired
        public SecurityController(EventService eventService) {
            this.eventService = eventService;
        }

        @GetMapping("/events")
        public List<Event> showAllEvents() {
            return eventService.showAllLogs();
        }
    }
  learner_created: true
- name: src/account/controller/AccountController.java
  visible: true
  text: |
    package account.controller;

    import account.dto.payment.PaymentDTO;
    import account.dto.user.StatusResponseDTO;
    import account.mapper.ModelMapper;
    import account.model.payment.Payment;
    import account.model.user.User;
    import account.service.PaymentService;
    import account.service.UserService;
    import account.validation.ValidDate;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.http.HttpStatus;
    import org.springframework.http.ResponseEntity;
    import org.springframework.security.core.annotation.AuthenticationPrincipal;
    import org.springframework.security.core.userdetails.UserDetails;
    import org.springframework.validation.annotation.Validated;
    import org.springframework.web.bind.annotation.*;
    import javax.validation.Valid;
    import javax.validation.constraints.NotEmpty;
    import java.util.Comparator;
    import java.util.List;
    import java.util.stream.Collectors;

    @Validated
    @RestController
    public class AccountController {

        private final UserService userService;
        private final PaymentService paymentService;
        private final ModelMapper modelMapper;

        @Autowired
        public AccountController(UserService userService, PaymentService paymentService, ModelMapper modelMapper) {
            this.userService = userService;
            this.paymentService = paymentService;
            this.modelMapper = modelMapper;
        }

        @PostMapping("/api/acct/payments")
        public StatusResponseDTO uploadPayrolls(@RequestBody
                                                @NotEmpty(message = "Input salary list can't be empty.")
                                                List<@Valid PaymentDTO> payrollDTO) {

            List<Payment> payroll = payrollDTO
                    .stream()
                    .map(modelMapper::mapToEntity)
                    .collect(Collectors.toList());

            paymentService.savePayments(payroll);

            return new StatusResponseDTO("Added successfully!");
        }

        @PutMapping("/api/acct/payments")
        public StatusResponseDTO updatePayment(@Valid @RequestBody PaymentDTO dto) {
            Payment payment = modelMapper.mapToEntity(dto);
            paymentService.updatePayment(payment);

            return new StatusResponseDTO("Updated successfully!");
        }

        @GetMapping("/api/empl/payment")
        public ResponseEntity<?> getPayment(@ValidDate @RequestParam(required = false) String period,
                                            @AuthenticationPrincipal UserDetails userDetails) {

            if (period == null) {
                User user = userService.findUserByEmail(userDetails.getUsername());
                return new ResponseEntity<>(
                        user.getPayments()
                                .stream()
                                .sorted(Comparator.comparing(Payment::getPeriod).reversed())
                                .map(modelMapper::mapToDTO)
                                .collect(Collectors.toList()),
                        HttpStatus.OK);
            } else {
                Payment payment = paymentService.getPayment(userDetails.getUsername(), period);
                return new ResponseEntity<>(modelMapper.mapToDTO(payment), HttpStatus.OK);
            }
        }
    }
  learner_created: true
- name: src/account/dto/user/StatusResponseDTO.java
  visible: true
  text: |
    package account.dto.user;

    import lombok.Getter;
    import lombok.RequiredArgsConstructor;

    @Getter
    @RequiredArgsConstructor
    public class StatusResponseDTO {
        private final String status;
    }
  learner_created: true
- name: src/account/service/PaymentService.java
  visible: true
  text: |
    package account.service;

    import account.exception.PaymentNotFoundException;
    import account.model.payment.Payment;
    import account.repository.PaymentRepository;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.http.HttpStatus;
    import org.springframework.stereotype.Service;
    import org.springframework.web.server.ResponseStatusException;
    import javax.transaction.Transactional;
    import java.time.YearMonth;
    import java.time.format.DateTimeFormatter;
    import java.util.List;

    @Service
    public class PaymentService {

        private final PaymentRepository paymentRepository;

        @Autowired
        public PaymentService(PaymentRepository paymentRepository) {
            this.paymentRepository = paymentRepository;
        }

        @Transactional
        public void savePayments(List<Payment> payroll) {
            payroll.forEach(p -> {
                if (paymentRepository.findByEmailAndPeriod(p.getEmail(), p.getPeriod()).isPresent()) {
                    throw new ResponseStatusException(HttpStatus.BAD_REQUEST);
                }
            });
            paymentRepository.saveAll(payroll);
        }

        @Transactional
        public void updatePayment(Payment paymentUpdate) {
            Payment payment = paymentRepository
                    .findByEmailAndPeriod(paymentUpdate.getEmail(), paymentUpdate.getPeriod())
                    .orElseThrow(PaymentNotFoundException::new);
            payment.setSalary(paymentUpdate.getSalary());
            paymentRepository.save(payment);
        }

        public Payment getPayment(String email, String period) {
            return paymentRepository.findByEmailAndPeriod(email, YearMonth.parse(period,
                            DateTimeFormatter.ofPattern("MM-yyyy")).atDay(1))
                    .orElseThrow(PaymentNotFoundException::new);
        }
    }
  learner_created: true
- name: src/account/model/user/AccessOperation.java
  visible: true
  text: |
    package account.model.user;

    public enum AccessOperation {
        LOCK,
        UNLOCK
    }
  learner_created: true
- name: src/account/dto/user/ChangeAccessDTO.java
  visible: true
  text: |
    package account.dto.user;

    import lombok.Getter;
    import lombok.RequiredArgsConstructor;

    @Getter
    @RequiredArgsConstructor
    public class ChangeAccessDTO {
        private final String user;
        private final String operation;
    }
  learner_created: true
- name: src/account/exception/UserNotFoundException.java
  visible: true
  text: |
    package account.exception;

    import org.springframework.http.HttpStatus;
    import org.springframework.web.bind.annotation.ResponseStatus;

    @ResponseStatus(code = HttpStatus.NOT_FOUND, reason = "User not found!")
    public class UserNotFoundException extends RuntimeException {
    }
  learner_created: true
- name: src/account/model/user/Role.java
  visible: true
  text: |
    package account.model.user;

    public enum Role {
        ADMINISTRATOR,
        AUDITOR,
        ACCOUNTANT,
        USER;

        public String withPrefix() {
            return "ROLE_" + this.name();
        }
    }
  learner_created: true
- name: src/account/dto/payment/PaymentDTO.java
  visible: true
  text: |
    package account.dto.payment;

    import account.validation.ValidDate;
    import account.validation.ValidEmail;
    import com.fasterxml.jackson.annotation.JsonProperty;
    import lombok.Getter;
    import lombok.RequiredArgsConstructor;

    import javax.validation.constraints.Positive;

    @Getter
    @RequiredArgsConstructor
    public class PaymentDTO {
        @ValidEmail
        @JsonProperty("employee")
        private final String email;
        @ValidDate
        private final String period;
        private final @Positive Long salary;
    }
  learner_created: true
- name: src/account/controller/AuthController.java
  visible: true
  text: |
    package account.controller;

    import account.dto.user.NewPasswordDTO;
    import account.dto.user.PasswordChangedDTO;
    import account.dto.user.UserDTO;
    import account.mapper.ModelMapper;
    import account.model.user.User;
    import account.service.UserService;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.security.core.annotation.AuthenticationPrincipal;
    import org.springframework.security.core.userdetails.UserDetails;
    import org.springframework.web.bind.annotation.PostMapping;
    import org.springframework.web.bind.annotation.RequestBody;
    import org.springframework.web.bind.annotation.RequestMapping;
    import org.springframework.web.bind.annotation.RestController;
    import javax.validation.Valid;

    @RestController
    @RequestMapping("/api/auth")
    public class AuthController {

        private final UserService userService;
        private final ModelMapper modelMapper;

        @Autowired
        public AuthController(UserService userService, ModelMapper modelMapper) {
            this.userService = userService;
            this.modelMapper = modelMapper;
        }

        @PostMapping("/signup")
        public UserDTO registerUser(@RequestBody @Valid UserDTO userDTO) {
            User user = modelMapper.mapToEntity(userDTO);
            return modelMapper.mapToDTO(userService.registerUser(user));
        }

        @PostMapping("/changepass")
        public PasswordChangedDTO changePassword(@RequestBody @Valid NewPasswordDTO passwordDTO,
                                                 @AuthenticationPrincipal UserDetails userDetails) {

            userService.changePassword(userDetails.getUsername(), passwordDTO.getNewPassword());
            return new PasswordChangedDTO(userDetails.getUsername());
        }
    }
  learner_created: true
- name: src/account/dto/user/UserDTO.java
  visible: true
  text: |
    package account.dto.user;

    import com.fasterxml.jackson.annotation.JsonProperty;
    import lombok.*;
    import java.util.List;

    @Data
    @AllArgsConstructor
    @Builder
    public class UserDTO {
        private Long id;
        private String name;
        private String lastname;
        private String email;
        @JsonProperty(access = JsonProperty.Access.WRITE_ONLY)
        private String password;
        private List<String> roles;
    }
  learner_created: true
- name: src/account/model/user/RoleOperation.java
  visible: true
  text: |
    package account.model.user;

    public enum RoleOperation {
        REMOVE,
        GRANT
    }
  learner_created: true
- name: src/account/validation/validator/DateValidator.java
  visible: true
  text: |
    package account.validation.validator;

    import account.validation.ValidDate;

    import javax.validation.ConstraintValidator;
    import javax.validation.ConstraintValidatorContext;

    public class DateValidator implements ConstraintValidator<ValidDate, String> {
        @Override
        public boolean isValid(String string, ConstraintValidatorContext context) {
            if (string == null)
                return true;
            return (string
                    .strip()
                    .replace("\"", "")
                    .strip().matches("^(1[0-2]|0?\\d)-20\\d{2}$"));
        }
    }
  learner_created: true
- name: src/account/repository/PaymentRepository.java
  visible: true
  text: |
    package account.repository;

    import account.model.payment.Payment;
    import org.springframework.data.jpa.repository.JpaRepository;
    import org.springframework.stereotype.Repository;
    import java.time.LocalDate;
    import java.util.Optional;

    @Repository
    public interface PaymentRepository extends JpaRepository<Payment, Long> {
        Optional<Payment> findByEmailAndPeriod(String email, LocalDate period);
    }
  learner_created: true
- name: src/account/exception/UserExistException.java
  visible: true
  text: |
    package account.exception;

    import org.springframework.http.HttpStatus;
    import org.springframework.web.bind.annotation.ResponseStatus;

    @ResponseStatus(code = HttpStatus.BAD_REQUEST, reason = "User exist!")
    public class UserExistException extends RuntimeException { }
  learner_created: true
- name: src/account/util/Formatter.java
  visible: true
  text: |
    package account.util;

    import java.time.LocalDate;
    import java.time.YearMonth;
    import java.time.format.DateTimeFormatter;

    public class Formatter {
        private Formatter() {
        }

        public static String formatSalary(Long salary) {
            return String.format("%d dollar(s) %d cent(s)",
                    salary / 100,
                    salary % 100);
        }

        public static LocalDate stringToDate(String period) {
            return YearMonth.parse(period, DateTimeFormatter.ofPattern("MM-yyyy")).atDay(1);
        }

        public static String dateToString(LocalDate period) {
            return period.format(DateTimeFormatter.ofPattern("MMMM-yyyy"));
        }
    }
  learner_created: true
- name: src/account/util/AppUtils.java
  visible: true
  text: |
    package account.util;

    import account.model.user.AccessOperation;
    import account.model.user.Role;
    import org.springframework.http.HttpStatus;
    import org.springframework.web.server.ResponseStatusException;

    public class AppUtils {
        private AppUtils() {
        }

        public static <T extends Enum<T>> T valueOf(Class<T> enumType, String name) {
            try {
                return Enum.valueOf(enumType, name);
            } catch (Exception e) {
                if (enumType.equals(Role.class)) {
                    throw new ResponseStatusException(HttpStatus.NOT_FOUND, "Role not found!");
                } else if (enumType.equals(AccessOperation.class)) {
                    throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Invalid Operation");
                } else {
                    throw new ResponseStatusException(HttpStatus.BAD_REQUEST);
                }
            }
        }
    }
  learner_created: true
- name: src/account/mapper/ModelMapper.java
  visible: true
  text: |
    package account.mapper;

    import account.dto.payment.PaymentDTO;
    import account.dto.payment.PaymentResponseDTO;
    import account.dto.user.UserDTO;
    import account.model.payment.Payment;
    import account.model.user.Role;
    import account.model.user.User;
    import account.service.UserService;
    import account.util.Formatter;
    import lombok.AllArgsConstructor;
    import org.springframework.stereotype.Component;

    import java.util.stream.Collectors;

    @Component
    @AllArgsConstructor
    public class ModelMapper {
        private final UserService userService;

        public User mapToEntity(UserDTO dto) {
            return User.builder()
                    .name(dto.getName())
                    .lastname(dto.getLastname())
                    .email(dto.getEmail())
                    .password(dto.getPassword())
                    .isAccountNonLocked(true)
                    .build();
        }

        public UserDTO mapToDTO(User user) {
            return UserDTO.builder()
                    .id(user.getId())
                    .name(user.getName())
                    .lastname(user.getLastname())
                    .email(user.getEmail())
                    .roles(user.getRoles().stream()
                            .map(Role::withPrefix)
                            .sorted(String::compareTo)
                            .collect(Collectors.toList()))
                    .build();
        }

        public Payment mapToEntity(PaymentDTO dto) {
            return Payment.builder()
                    .email(dto.getEmail())
                    .period(Formatter.stringToDate(dto.getPeriod()))
                    .salary(dto.getSalary())
                    .user(userService.findUserByEmail(dto.getEmail()))
                    .build();
        }

        public PaymentResponseDTO mapToDTO(Payment payment) {
            return PaymentResponseDTO.builder()
                    .name(payment.getUser().getName())
                    .lastname(payment.getUser().getLastname())
                    .period(Formatter.dateToString(payment.getPeriod()))
                    .salary(Formatter.formatSalary(payment.getSalary()))
                    .build();
        }
    }
  learner_created: true
- name: src/account/repository/EventRepository.java
  visible: true
  text: |
    package account.repository;

    import account.model.event.Event;
    import org.springframework.data.jpa.repository.JpaRepository;
    import org.springframework.stereotype.Repository;

    @Repository
    public interface EventRepository extends JpaRepository<Event, Long> {
    }
  learner_created: true
- name: src/account/listener/AuthSuccessListener.java
  visible: true
  text: |
    package account.listener;

    import account.service.LoginAttemptService;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.context.ApplicationListener;
    import org.springframework.context.annotation.Configuration;
    import org.springframework.security.authentication.event.AuthenticationSuccessEvent;

    @Configuration
    public class AuthSuccessListener implements ApplicationListener<AuthenticationSuccessEvent> {

        private final LoginAttemptService loginAttemptService;

        @Autowired
        public AuthSuccessListener(LoginAttemptService loginAttemptService) {
            this.loginAttemptService = loginAttemptService;
        }

        @Override
        public void onApplicationEvent(AuthenticationSuccessEvent event) {
            loginAttemptService.loginSuccess(event.getAuthentication().getName());
        }
    }
  learner_created: true
- name: src/account/dto/payment/PaymentResponseDTO.java
  visible: true
  text: |
    package account.dto.payment;

    import lombok.*;

    @Getter
    @Builder
    public class PaymentResponseDTO {
        private final String name;
        private final String lastname;
        private final String period;
        private final String salary;
    }
  learner_created: true
- name: src/account/model/event/Event.java
  visible: true
  text: |+
    package account.model.event;

    import com.fasterxml.jackson.annotation.JsonIgnore;
    import lombok.*;
    import javax.persistence.*;
    import java.time.LocalDateTime;
    import java.time.format.DateTimeFormatter;

    @Getter
    @Setter
    @Entity
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public class Event {
        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        @JsonIgnore
        private Long id;

        @JsonIgnore
        private final String date = DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm:ss").format(LocalDateTime.now());

        @Enumerated(EnumType.STRING)
        private Action action;

        private String subject;

        private String object;

        private String path;
    }

  learner_created: true
- name: src/account/validation/ValidDate.java
  visible: true
  text: |
    package account.validation;

    import account.validation.validator.DateValidator;

    import javax.validation.Constraint;
    import javax.validation.Payload;
    import java.lang.annotation.Retention;
    import java.lang.annotation.RetentionPolicy;

    @Constraint(validatedBy = DateValidator.class)
    @Retention(RetentionPolicy.RUNTIME)
    public @interface ValidDate {
        String message() default "Date must be in MMMM-YYYY format";

        Class<?>[] groups() default {};

        Class<? extends Payload>[] payload() default {};
    }
  learner_created: true
- name: src/account/repository/UserRepository.java
  visible: true
  text: |
    package account.repository;

    import account.model.user.User;
    import org.springframework.data.jpa.repository.JpaRepository;
    import org.springframework.stereotype.Repository;
    import java.util.Optional;

    @Repository
    public interface UserRepository extends JpaRepository<User, Long> {
        Optional<User> findByEmailIgnoreCase(String email);
    }
  learner_created: true
- name: src/account/model/event/Action.java
  visible: true
  text: |
    package account.model.event;

    public enum Action {
        CREATE_USER,
        CHANGE_PASSWORD,
        ACCESS_DENIED,
        LOGIN_FAILED,
        GRANT_ROLE,
        REMOVE_ROLE,
        LOCK_USER,
        UNLOCK_USER,
        DELETE_USER,
        BRUTE_FORCE
    }
  learner_created: true
- name: src/account/security/UserDetailsImpl.java
  visible: true
  text: |
    package account.security;

    import account.model.user.User;
    import org.springframework.security.core.GrantedAuthority;
    import org.springframework.security.core.authority.SimpleGrantedAuthority;
    import org.springframework.security.core.userdetails.UserDetails;
    import java.util.*;
    import java.util.stream.Collectors;

    public class UserDetailsImpl implements UserDetails {

        private final String username;
        private final String password;
        private final boolean isAccountNonLocked;
        private final List<GrantedAuthority> authorityList;

        public UserDetailsImpl(User user) {
            this.username = user.getEmail();
            this.password = user.getPassword();
            this.isAccountNonLocked = user.isAccountNonLocked();
            this.authorityList = user.getRoles().stream().
                    map(x -> new SimpleGrantedAuthority(x.withPrefix())).
                    collect(Collectors.toList());
        }

        @Override
        public Collection<? extends GrantedAuthority> getAuthorities() {
            return this.authorityList;
        }

        @Override
        public String getPassword() {
            return this.password;
        }

        @Override
        public String getUsername() {
            return this.username;
        }

        @Override
        public boolean isAccountNonExpired() {
            return true;
        }

        @Override
        public boolean isAccountNonLocked() {
            return this.isAccountNonLocked;
        }

        @Override
        public boolean isCredentialsNonExpired() {
            return true;
        }

        @Override
        public boolean isEnabled() {
            return true;
        }
    }
  learner_created: true
- name: src/account/validation/validator/PasswordValidator.java
  visible: true
  text: |
    package account.validation.validator;

    import account.exception.BreachedPasswordException;
    import account.exception.PasswordLengthException;
    import account.validation.ValidPassword;
    import org.springframework.http.HttpStatus;
    import org.springframework.web.server.ResponseStatusException;

    import javax.validation.ConstraintValidator;
    import javax.validation.ConstraintValidatorContext;
    import java.util.List;

    public class PasswordValidator implements ConstraintValidator<ValidPassword, String> {
        private final List<String> breachedPasswords = List.of(
                "PasswordForJanuary",
                "PasswordForFebruary",
                "PasswordForMarch",
                "PasswordForApril",
                "PasswordForMay",
                "PasswordForJune",
                "PasswordForJuly",
                "PasswordForAugust",
                "PasswordForSeptember",
                "PasswordForOctober",
                "PasswordForNovember",
                "PasswordForDecember");

        @Override
        public boolean isValid(String password, ConstraintValidatorContext context) {
            if (password == null) {
                throw new ResponseStatusException(HttpStatus.BAD_REQUEST);
            } else if (breachedPasswords.contains(password)) {
                throw new BreachedPasswordException();
            } else if (password.length() < 12) {
                throw new PasswordLengthException();
            }
            return true;
        }
    }
  learner_created: true
- name: src/account/exception/PaymentNotFoundException.java
  visible: true
  text: |
    package account.exception;

    import org.springframework.http.HttpStatus;
    import org.springframework.web.bind.annotation.ResponseStatus;

    @ResponseStatus(value = HttpStatus.BAD_REQUEST, reason = "Payment not found!")
    public class PaymentNotFoundException extends RuntimeException {
    }
  learner_created: true
- name: src/account/model/user/User.java
  visible: true
  text: |
    package account.model.user;

    import account.model.payment.Payment;
    import account.validation.ValidEmail;
    import account.validation.ValidPassword;
    import com.fasterxml.jackson.annotation.JsonProperty;
    import lombok.*;
    import javax.persistence.*;
    import javax.validation.constraints.*;
    import java.util.*;

    @Entity(name = "User")
    @Table(name = "user")
    @Getter
    @Setter
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public class User {
        @Id
        @GeneratedValue
        private Long id;

        @NotEmpty
        private String name;

        @NotEmpty
        private String lastname;

        @NotEmpty
        @ValidEmail
        private String email;

        @ElementCollection(fetch = FetchType.EAGER)
        private final Set<Role> roles = new HashSet<>();

        @NotEmpty
        @ValidPassword
        @JsonProperty(access = JsonProperty.Access.WRITE_ONLY)
        private String password;

        @OneToMany(mappedBy = "user")
        private List<Payment> payments;

        private boolean isAccountNonLocked;

        private int failedLoginAttempts;
    }
  learner_created: true
- name: src/account/dto/user/DeleteUserResponseDTO.java
  visible: true
  text: |
    package account.dto.user;

    import lombok.Getter;
    import lombok.RequiredArgsConstructor;

    @Getter
    @RequiredArgsConstructor
    public class DeleteUserResponseDTO {
        private final String status = "Deleted successfully!";
        private final String user;
    }
  learner_created: true
- name: src/account/exception/PasswordLengthException.java
  visible: true
  text: |
    package account.exception;

    import org.springframework.http.HttpStatus;
    import org.springframework.web.bind.annotation.ResponseStatus;

    @ResponseStatus(value = HttpStatus.BAD_REQUEST, reason = "Password length must be 12 chars minimum!")
    public class PasswordLengthException extends RuntimeException{
    }
  learner_created: true
- name: src/account/service/EventService.java
  visible: true
  text: |
    package account.service;

    import account.model.event.Action;
    import account.model.event.Event;
    import account.repository.EventRepository;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.stereotype.Service;
    import java.util.List;

    @Service
    public class EventService {

        private final EventRepository eventRepository;

        @Autowired
        public EventService(EventRepository eventRepository) {
            this.eventRepository = eventRepository;
        }

        public void saveLog(Action action, String subject, String object, String path) {
            eventRepository.save(Event.builder()
                    .action(action)
                    .subject(subject)
                    .object(object)
                    .path(path)
                    .build());
        }

        public List<Event> showAllLogs() {
            return eventRepository.findAll();
        }
    }
  learner_created: true
- name: src/account/service/LoginAttemptService.java
  visible: true
  text: |
    package account.service;

    import account.model.event.Action;
    import account.model.user.Role;
    import account.model.user.User;
    import account.repository.UserRepository;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.stereotype.Service;

    @Service
    public class LoginAttemptService {
        private static final int MAX_ATTEMPT = 5;
        private final UserRepository userRepository;
        private final EventService eventService;

        @Autowired
        public LoginAttemptService(UserRepository userRepository, EventService eventService) {
            super();
            this.userRepository = userRepository;
            this.eventService = eventService;
        }

        public void loginSuccess(String email) {
            User user = userRepository.findByEmailIgnoreCase(email).orElseGet(User::new);
            user.setFailedLoginAttempts(0);
            userRepository.save(user);
        }

        public void loginFailure(String key, String uri) {
            if (userRepository.findByEmailIgnoreCase(key).isEmpty()) {
                return;
            }

            User user = userRepository.findByEmailIgnoreCase(key).get();

            if (user.getRoles().contains(Role.ADMINISTRATOR)) {
                return;
            }

            user.setFailedLoginAttempts(user.getFailedLoginAttempts() + 1);

            if (user.getFailedLoginAttempts() >= MAX_ATTEMPT) {
                user.setAccountNonLocked(false);
                eventService.saveLog(Action.BRUTE_FORCE, key, uri, uri);
                eventService.saveLog(Action.LOCK_USER, key, String.format("Lock user %s", key), uri);
            }

            userRepository.save(user);
        }
    }
  learner_created: true
- name: src/account/security/UserDetailsServiceImpl.java
  visible: true
  text: |
    package account.security;

    import account.model.event.Action;
    import account.model.user.User;
    import account.repository.UserRepository;
    import account.service.EventService;
    import org.springframework.http.HttpStatus;
    import org.springframework.security.core.userdetails.UserDetails;
    import org.springframework.security.core.userdetails.UserDetailsService;
    import org.springframework.stereotype.Service;
    import org.springframework.web.server.ResponseStatusException;
    import javax.servlet.http.HttpServletRequest;
    import java.util.Optional;

    @Service
    public class UserDetailsServiceImpl implements UserDetailsService {

        private final UserRepository userRepository;
        private final EventService eventService;
        private final HttpServletRequest request;

        public UserDetailsServiceImpl(UserRepository userRepository,
                                      EventService eventService,
                                      HttpServletRequest request) {
            this.userRepository = userRepository;
            this.eventService = eventService;
            this.request = request;
        }

        @Override
        public UserDetails loadUserByUsername(String username){
            Optional<User> user = userRepository.findByEmailIgnoreCase(username);
            return user.map(UserDetailsImpl::new)
                    .orElseThrow(() -> {
                        String path = request.getRequestURI().substring(request.getContextPath().length());
                        eventService.saveLog(Action.LOGIN_FAILED, username, path, path);
                        throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "User doesn't exist");
                    });
        }
    }
  learner_created: true
- name: src/account/controller/AdminController.java
  visible: true
  text: |
    package account.controller;

    import account.dto.user.StatusResponseDTO;
    import account.dto.user.ChangeAccessDTO;
    import account.dto.user.DeleteUserResponseDTO;
    import account.dto.user.RoleDTO;
    import account.dto.user.UserDTO;
    import account.mapper.ModelMapper;
    import account.model.user.User;
    import account.security.UserDetailsImpl;
    import account.service.UserService;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.security.core.annotation.AuthenticationPrincipal;
    import org.springframework.security.core.userdetails.UserDetails;
    import org.springframework.web.bind.annotation.*;
    import java.util.List;
    import java.util.stream.Collectors;

    @RestController
    @RequestMapping("/api/admin")
    public class AdminController {
        private final UserService userService;
        private final ModelMapper modelMapper;

        @Autowired
        public AdminController(UserService userService, ModelMapper modelMapper) {
            this.userService = userService;
            this.modelMapper = modelMapper;
        }

        @GetMapping("/user")
        public List<UserDTO> showAllUserInfo() {
            return userService.getAllUsersAndInfo().stream()
                    .map(modelMapper::mapToDTO)
                    .collect(Collectors.toList());
        }

        @DeleteMapping("/user/{email}")
        public DeleteUserResponseDTO deleteUser(@PathVariable String email,
                                                @AuthenticationPrincipal UserDetails userDetails) {

            userService.deleteUser(email, userDetails.getUsername());
            return new DeleteUserResponseDTO(email);
        }

        @PutMapping("/user/role")
        public UserDTO updateUserRole(@RequestBody RoleDTO roleDTO,
                                      @AuthenticationPrincipal UserDetailsImpl userDetails) {
            User user = userService.updateUserRole(roleDTO, userDetails.getUsername());
            return modelMapper.mapToDTO(user);
        }

        @PutMapping("/user/access")
        public StatusResponseDTO changeUserAccess(@RequestBody ChangeAccessDTO accessDTO,
                                                  @AuthenticationPrincipal UserDetails userDetails) {
            return userService.changeAccess(accessDTO, userDetails.getUsername());
        }
    }
  learner_created: true
- name: src/account/listener/AuthFailureListener.java
  visible: true
  text: |
    package account.listener;

    import account.model.event.Action;
    import account.service.EventService;
    import account.service.LoginAttemptService;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.context.ApplicationListener;
    import org.springframework.context.annotation.Configuration;
    import org.springframework.security.authentication.event.AuthenticationFailureBadCredentialsEvent;
    import javax.servlet.http.HttpServletRequest;

    @Configuration
    public class AuthFailureListener implements ApplicationListener<AuthenticationFailureBadCredentialsEvent> {
        private final LoginAttemptService loginAttemptService;
        private final EventService eventService;
        private final HttpServletRequest request;

        @Autowired
        public AuthFailureListener(LoginAttemptService loginAttemptService,
                                   EventService eventService,
                                   HttpServletRequest request) {
            this.loginAttemptService = loginAttemptService;
            this.eventService = eventService;
            this.request = request;
        }

        @Override
        public void onApplicationEvent(AuthenticationFailureBadCredentialsEvent event) {
            eventService.saveLog(Action.LOGIN_FAILED, event.getAuthentication().getName(),
                    request.getRequestURI(), request.getRequestURI());

            String username = event.getAuthentication().getName();
            loginAttemptService.loginFailure(username, request.getRequestURI());
        }
    }
  learner_created: true
- name: src/account/model/payment/Payment.java
  visible: true
  text: |
    package account.model.payment;

    import account.model.user.User;
    import lombok.*;
    import javax.persistence.*;
    import java.time.LocalDate;

    @Entity(name = "Payment")
    @Table(name = "payment")
    @Getter
    @Setter
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public class Payment {
        @Id
        @GeneratedValue
        private Long id;

        @NonNull
        private String email;

        @NonNull
        private LocalDate period;

        @NonNull
        private Long salary;

        @ManyToOne
        @JoinColumn(name="user_id")
        private User user;
    }
  learner_created: true
- name: src/account/security/ApplicationSecurityConfig.java
  visible: true
  text: |
    package account.security;

    import account.model.event.Action;
    import account.model.user.Role;
    import account.service.EventService;
    import com.fasterxml.jackson.databind.ObjectMapper;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.context.annotation.Bean;
    import org.springframework.http.HttpStatus;
    import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
    import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
    import org.springframework.security.config.annotation.web.builders.HttpSecurity;
    import org.springframework.security.config.annotation.web.builders.WebSecurity;
    import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
    import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
    import org.springframework.security.config.http.SessionCreationPolicy;
    import org.springframework.security.core.context.SecurityContextHolder;
    import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
    import org.springframework.security.crypto.password.PasswordEncoder;
    import org.springframework.security.web.AuthenticationEntryPoint;
    import org.springframework.security.web.access.AccessDeniedHandler;
    import java.time.LocalDateTime;
    import java.time.format.DateTimeFormatter;
    import java.util.Map;

    @EnableWebSecurity
    public class ApplicationSecurityConfig extends WebSecurityConfigurerAdapter {

        private final UserDetailsServiceImpl userDetailsService;
        private final EventService eventService;

        @Autowired
        public ApplicationSecurityConfig(UserDetailsServiceImpl userDetailsService, EventService eventService) {
            this.userDetailsService = userDetailsService;
            this.eventService = eventService;
        }

        @Override
        protected void configure(HttpSecurity http) throws Exception {
            http.authorizeRequests()
                    .mvcMatchers("/api/auth/signup", "/actuator/shutdown").permitAll()
                    .mvcMatchers("/api/security/**").hasRole(Role.AUDITOR.name())
                    .mvcMatchers("/api/empl/payment").hasAnyRole(Role.ACCOUNTANT.name(), Role.USER.name())
                    .mvcMatchers("/api/acct/payments").hasRole(Role.ACCOUNTANT.name())
                    .mvcMatchers("/api/admin/**").hasRole(Role.ADMINISTRATOR.name())
                    .anyRequest().authenticated()
                    .and()
                    .exceptionHandling().accessDeniedHandler(accessDeniedHandler())
                    .and()
                    .csrf().disable().headers().frameOptions().disable()
                    .and()
                    .httpBasic().authenticationEntryPoint(getAuthenticationEntryPoint())
                    .and()
                    .sessionManagement()
                    .sessionCreationPolicy(SessionCreationPolicy.STATELESS);
        }

        @Override
        public void configure(WebSecurity web) {
            web.ignoring().antMatchers("/h2-console/**");
        }

        @Override
        protected void configure(AuthenticationManagerBuilder auth) {
            auth.authenticationProvider(daoAuthenticationProvider());
        }

        @Bean
        public DaoAuthenticationProvider daoAuthenticationProvider() {
            DaoAuthenticationProvider provider = new DaoAuthenticationProvider();
            provider.setPasswordEncoder(getPasswordEncoder());
            provider.setUserDetailsService(userDetailsService);
            return provider;
        }

        @Bean
        public PasswordEncoder getPasswordEncoder() {
            return new BCryptPasswordEncoder(13);
        }

        @Bean
        public AccessDeniedHandler accessDeniedHandler() {
            return (request, response, ex) -> {
                eventService.saveLog(Action.ACCESS_DENIED,
                        SecurityContextHolder.getContext().getAuthentication().getName(),
                        request.getRequestURI(), request.getRequestURI());
                response.sendError(HttpStatus.FORBIDDEN.value(), "Access Denied!");
            };
        }

        @Bean
        AuthenticationEntryPoint getAuthenticationEntryPoint() {
            return (request, response, authException) ->
            {
                response.setStatus(HttpStatus.UNAUTHORIZED.value());
                response.getOutputStream().println(new ObjectMapper().writeValueAsString(Map.of(
                        "timestamp", DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm:ss").format(LocalDateTime.now()),
                        "status", 401,
                        "error", "Unauthorized",
                        "message", "User account is locked",
                        "path", request.getRequestURI()
                )));
            };
        }
    }
  learner_created: true
- name: src/account/dto/user/PasswordChangedDTO.java
  visible: true
  text: |
    package account.dto.user;

    import lombok.Getter;
    import lombok.RequiredArgsConstructor;

    @Getter
    @RequiredArgsConstructor
    public class PasswordChangedDTO {
        private final String status = "The password has been updated successfully";
        private final String email;
    }
  learner_created: true
- name: src/account/dto/user/NewPasswordDTO.java
  visible: true
  text: |+
    package account.dto.user;

    import account.validation.ValidPassword;
    import com.fasterxml.jackson.annotation.JsonProperty;
    import lombok.Data;
    import javax.validation.constraints.NotEmpty;

    @Data
    public class NewPasswordDTO {
        @NotEmpty
        @ValidPassword
        @JsonProperty("new_password")
        private String newPassword;
    }

  learner_created: true
- name: src/account/service/UserService.java
  visible: true
  text: |
    package account.service;

    import account.dto.user.StatusResponseDTO;
    import account.dto.user.ChangeAccessDTO;
    import account.dto.user.RoleDTO;
    import account.exception.UserExistException;
    import account.exception.UserNotFoundException;
    import account.model.event.Action;
    import account.model.user.AccessOperation;
    import account.model.user.Role;
    import account.model.user.RoleOperation;
    import account.model.user.User;
    import account.repository.UserRepository;
    import account.util.AppUtils;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.http.HttpStatus;
    import org.springframework.security.crypto.password.PasswordEncoder;
    import org.springframework.stereotype.Service;
    import org.springframework.util.StringUtils;
    import org.springframework.web.server.ResponseStatusException;
    import java.util.*;

    @Service
    public class UserService {
        private static final Set<Role> BUSINESS_GROUP = Set.of(Role.USER, Role.ACCOUNTANT, Role.AUDITOR);
        private final UserRepository userRepository;
        private final PasswordEncoder passwordEncoder;
        private final EventService eventService;

        @Autowired
        public UserService(UserRepository userRepository, PasswordEncoder passwordEncoder, EventService eventService) {
            this.userRepository = userRepository;
            this.passwordEncoder = passwordEncoder;
            this.eventService = eventService;
        }

        public User findUserByEmail(String email) throws ResponseStatusException {
            return userRepository
                    .findByEmailIgnoreCase(email)
                    .orElseThrow(UserNotFoundException::new);
        }

        public User registerUser(User user) {
            if (userRepository.findByEmailIgnoreCase(user.getEmail()).isPresent()) {
                throw new UserExistException();
            }

            user.getRoles().add(userRepository.findAll().isEmpty() ? Role.ADMINISTRATOR : Role.USER);
            user.setEmail(user.getEmail().toLowerCase());
            user.setPassword(passwordEncoder.encode(user.getPassword()));
            eventService.saveLog(Action.CREATE_USER, "Anonymous", user.getEmail(), "/api/auth/signup");

            return userRepository.save(user);
        }

        public void changePassword(String email, String newPassword) {
            User user = findUserByEmail(email);

            if (passwordEncoder.matches(newPassword, user.getPassword())) {
                throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "The passwords must be different!");
            }

            user.setPassword(passwordEncoder.encode(newPassword));
            eventService.saveLog(Action.CHANGE_PASSWORD, user.getEmail(), user.getEmail(), "/api/auth/changepass");
            userRepository.save(user);
        }

        public List<User> getAllUsersAndInfo() {
            return userRepository.findAll();
        }

        public void deleteUser(String userEmail, String adminEmail) {
            User user = findUserByEmail(userEmail);

            if (user.getRoles().contains(Role.ADMINISTRATOR)) {
                throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Can't remove ADMINISTRATOR role!");
            }

            userRepository.delete(user);
            eventService.saveLog(Action.DELETE_USER, adminEmail, userEmail, "/api/admin/delete");
        }

        public User updateUserRole(RoleDTO roleDTO, String adminEmail) throws ResponseStatusException {
            User user = findUserByEmail(roleDTO.getUser());

            Role role = AppUtils.valueOf(Role.class, roleDTO.getRole());
            RoleOperation operation = AppUtils.valueOf(RoleOperation.class, roleDTO.getOperation());
            String invalidReason = null;

            if (operation.equals(RoleOperation.GRANT) && isCombiningRoles(user.getRoles(), role)) {
                invalidReason = "The user cannot combine administrative and business roles!";
            } else if (operation.equals(RoleOperation.GRANT) && user.getRoles().contains(role)) {
                invalidReason = "User already has the role";
            } else if (operation.equals(RoleOperation.REMOVE) && role.equals(Role.ADMINISTRATOR)) {
                invalidReason = "Can't remove ADMINISTRATOR role!";
            } else if (operation.equals(RoleOperation.REMOVE) && !user.getRoles().contains(role)) {
                invalidReason = "The user does not have a role!";
            } else if (operation.equals(RoleOperation.REMOVE) && user.getRoles().size() == 1) {
                invalidReason = "The user must have at least one role!";
            }

            if (invalidReason != null) {
                throw new ResponseStatusException(HttpStatus.BAD_REQUEST, invalidReason);
            }

            Action action;
            String fromOrTo;

            if (operation.equals(RoleOperation.GRANT)) {
                user.getRoles().add(role);
                action = Action.GRANT_ROLE;
                fromOrTo = "to";
            } else {
                user.getRoles().remove(role);
                action = Action.REMOVE_ROLE;
                fromOrTo = "from";
            }

            eventService.saveLog(action, adminEmail,
                    String.format("%s role %s %s %s", StringUtils.capitalize(roleDTO.getOperation().toLowerCase()),
                            role.name(), fromOrTo, user.getEmail()),"/api/admin/role");

            return userRepository.save(user);
        }

        public boolean isCombiningRoles(Set<Role> assignedRoles, Role requestedRole) {
            return adminWithBusinessRole(assignedRoles, requestedRole) ||
                    businessRoleWithAdmin(assignedRoles, requestedRole);
        }

        public boolean adminWithBusinessRole(Set<Role> assignedRoles, Role requestedRole) {
            return !Collections.disjoint(assignedRoles, BUSINESS_GROUP)
                    && requestedRole.equals(Role.ADMINISTRATOR);
        }

        public boolean businessRoleWithAdmin(Set<Role> assignedRoles, Role requestedRole) {
            return assignedRoles.contains(Role.ADMINISTRATOR) && BUSINESS_GROUP.contains(requestedRole);
        }

        public StatusResponseDTO changeAccess(ChangeAccessDTO accessDTO, String adminEmail) {
            Action action;
            User user = findUserByEmail(accessDTO.getUser());
            AccessOperation op = AppUtils.valueOf(AccessOperation.class, accessDTO.getOperation());

            if (user.getRoles().contains(Role.ADMINISTRATOR)) {
                throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Can't lock the ADMINISTRATOR!");
            }

            if (Objects.equals(op, AccessOperation.LOCK)) {
                user.setAccountNonLocked(false);
                action = Action.LOCK_USER;
            } else {
                user.setAccountNonLocked(true);
                user.setFailedLoginAttempts(0);
                action = Action.UNLOCK_USER;
            }

            userRepository.save(user);
            eventService.saveLog(action, adminEmail,
                    String.format("%s user %s", StringUtils.capitalize(op.name().toLowerCase()),
                            user.getEmail()), "/api/admin/access");

            return new StatusResponseDTO(String.format("User %s %sed!", user.getEmail(), op.name().toLowerCase()));
        }
    }
  learner_created: true
- name: src/account/validation/ValidPassword.java
  visible: true
  text: |
    package account.validation;

    import account.validation.validator.PasswordValidator;

    import javax.validation.Constraint;
    import javax.validation.Payload;
    import java.lang.annotation.Retention;
    import java.lang.annotation.RetentionPolicy;

    @Constraint(validatedBy = PasswordValidator.class)
    @Retention(RetentionPolicy.RUNTIME)
    public @interface ValidPassword {
        String message() default "";
        Class<?>[] groups() default {};
        Class<? extends Payload>[] payload() default {};
    }
  learner_created: true
- name: src/account/exception/BreachedPasswordException.java
  visible: true
  text: |
    package account.exception;

    import org.springframework.http.HttpStatus;
    import org.springframework.web.bind.annotation.ResponseStatus;

    @ResponseStatus(value = HttpStatus.BAD_REQUEST, reason = "The password is in the hacker's database!")
    public class BreachedPasswordException extends RuntimeException {
    }
  learner_created: true
- name: src/resources/keystore/keystore.p12
  visible: true
  learner_created: true
feedback_link: https://hyperskill.org/learn/step/16607#comment
status: Solved
feedback:
  message: Well done! You've finished the project. Select a new project on <a href="https://hyperskill.org/projects">Hyperskill</a>
    to continue learning.
  time: "Mon, 20 Mar 2023 21:22:17 UTC"
record: -1
